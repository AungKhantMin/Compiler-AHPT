A Pratical Theory of Programming Languges Series: Part 6 Describing Syntax in Programming Language
Syntax Programming language လို.ေၿပာလိုက္ရင္ ေတာ္ေတာ္မ်ားမ်ားက ဘာကိုေၿပးၿမင္သလဲဆုိရင္ သူတုိ.ရဲ. syntax ကုိပဲေၿပးၿမင္ပါတယ္။ Syntax ဆုိတာ သဒၵါ ေရးထံုး ေရးပံုေရးနည္းလုိ.ဆုိရမွာပါ။ Program တခုၿဖစ္ဖုိ. (မွန္တဲ့ program ေပါ့ေလ) အနည္းဆံုး လုိအပ္ခ်က္က သဒၵါနည္းအရ syntax အရမွန္ရမွာပါ။ ဆုိပါစုိ. variable ေၾကၿငာမယ္ဆုိရင္ C,C++,Java,C# လို language ေတြမွာ type ကိုအရင္ေရးရမယ္ ၿပီးမွ variable name လာမည္ ေနာက္ထပ္ variable ေတြေၾကၿငာခ်င္ရင္ comma ေလးခံ အားလံုးဆံုးသြားရင္ semicolon ေလးပိတ္ဆုိၿပီး rule ရိွပါတယ္။ Variable ေတြကို ေၾကၿငာကတည္းက initialized လုပ္လုိ.ရမယ္ေပါ့။ ဥပမာ ဆုိလို.ရိွရင္ ဒီပံုစံေပါ့ complete ေတာ့မၿဖစ္ဘူး ။ဥပမာ ၿပတာသက္သက္ပဲ။ ဒီလိုလာမယ္ေပါ့။
Declaration=> Type Identifier;
အေပၚက rule သည္ ေရွ.က Type လာမယ္ ေနာက္ Identifier လာရမယ္ ေနာက္ဆံုးမွာ semicolon လာရမယ္ဆုိၿပီးေရးထားတာေပါ့။ အဲ့ဒီ rule အရဆုိရင္ variable က တလံုးပဲေၾကၿငာလို.ရမယ္။ ေနာက္ၿပီး initialization လဲဘာမွလုပ္လို.မရဘူး။ ဒါကို Grammar rule လို.ေခၚတယ္။ Programming language တခုရဲ. syntax ကိုသတ္မွတ္တဲ့ေနရာမွာအဲ့လို Grammar rule ေတြနဲ. သတ္မွတ္ရတယ္။ ဒါဆုိရင္ Programming language ရဲ. Grammar rule ကုိၾကည့္ၿပီး ဘယ္လုိ program ေတြ ကို syntax ေတြကိုဘယ္လိုေတာ့ေရးလုိ.ရမယ္ ။ဘယ္လုိေတာ့ေရးလို.မရဘူး language ကဘယ္လိုေရးရင္ေတာ့ လက္ခံမယ္ ဘယ္လုိဆုိရင္ေတာ့လက္မခံဘူးဆုိတာကို သတ္မွတ္ေပးထားတာ။ Programming သင္တဲ့သူအမ်ားစုက programming လုိ.ေၿပာရင္ syntax လို.ပဲထင္ၾကတယ္ (တခ်ိဳ.ကလဲ for loop ဘယ္လိုပတ္တယ္ if ဘယ္လိုေရးတယ္ပဲဆုိၾကတယ္။ ဒါကုိ syntax ပါလားဆုိတာေတာင္မသိၾကဘူး)။ Programming ကုိေလ့လာတဲ့လူအမ်ားစုက ဒီေခတ္ဆုိပိုဆုိးတယ္ online က tutorial ေလာက္ဖတ္ တာ စာအုပ္ဖတ္တာ ဆရာဆီကသင္တာပဲလုပ္ၾကတယ္။ တကယ္က language တခုကုိေသခ်ာနားလည္ခ်င္ၿပီဆုိရင္ သူ.ရဲ. language specification ကိုမၿဖစ္မေနဖတ္ရမယ္။ C++,Java,C#,JavaScript စတာေတြမွာေတာ့ language specification ဆုိတာရိွတယ္။ ဒီ language ရဲ. syntax နဲ. semantic ကုိ ရွင္းၿပထားတဲ့ document ေတြလိုေၿပာရမယ္။ PHP, Ruby, Python အစရိွတာေတြမွာေတာ့ standard or specification မရိွၾကဘူး။ သူတုိ.က်ေတာ့ documentation ပဲရိွၾကတယ္။ ဘယ္လိုေၿပာေၿပာ Programming language တခုရဲ. syntax ကုိ အေပၚကလုိ Grammar rule ေတြသံုးၿပီး ေဖာ္ၿပၾကတယ္။ အဲ့ဒီေတာ့ အနိမ့္ဆံုးအဆင့္ language ရဲ. Grammar ကိုဖတ္ႏုိင္မွသာ ဒီ Language ရဲ. syntax ကုိနားလည္မွာလို. ဆုိရမယ္။
ဒါေၾကာင့္ခုနက အေပၚကေၿပာခဲ့တဲ့ Grammar rule ေတြ (technically က်ေတာ့ CFG (Context Free Grammar) လို.ေခၚတယ္)ကုိနားမလည္ရင္ language syntax ေတာင္ ေသခ်ာနားလည္တဲ့အဆင့္မရိွဘူးလို.ဆုိရမွာပဲ။ Programming langauge ေတြမွာအသံုးမ်ားတဲ့ Grammar ၂ မ်ိဳးရွိတယ္။ Regular grammar နဲ. Context Free grammar ဆိုၿပီးေတာ့။ Regular grammar သည္ lexcial element(variable ေတြဘယ္လိုေရးရမလဲ. literal ေတြဘယ္လိုေရးရမလဲ) ကုိသတ္မွတ္တဲ့ေနရာမွာသံုးတယ္။ Context Free Grammar ကုိကေ်တာ့ program statement ေတြ element ေတြ (ဥပမာ class definition , for loop etc) ေတြကိုေဖာ္ၿပတဲ့ေနရာမွာသံုးတယ္။ Regular language ေတြက recursive definition ပါလို.မရဘူး။ Context Free Grammar ေတြကေတာ့ပါလို.ရတယ္ ဒါေၾကာင့္ပိုေကာင္းတယ္။ ဥပမာ (parenthesis) ေတြ balance ညီရမယ္ (အဖြင့္အပိတ္ ညီရမယ္) ဆုိတာမ်ိဳးကို regular grammar နဲ.စစ္လို.မရဘူး Context free grammar နဲ.ပဲစစ္လို.၇တယ္။ ေနာက္ Context senstive gramamr ဆုိတာလဲရွိေသးတယ္။ သူကေတာ့Natural Language Processing ေတြမွာသံုးတယ္။ ဘာေၾကာင့္ context free grammar လို.ေခၚသလဲဆုိလို.ရိွ၇င္ သူ.ကုိ (Context Free Grammar ကို ) parse လုပ္ေနတံုးမွာ ေရွ.မွာဘာ parse လုပ္ထားလဲဆုိတာကို ေရွ.က information (ေနာက္က information ေရာ)သိစရာမလိုဘူး ဒါေၾကာင့္ context လြတ္တယ္။ဒါေၾကာင့္သူ.ကို context free grammar လို.ေခၚတယ္။ Regular grammar, Context Free grammar, context sensitive grammar ေတြကို meta language လုို.လဲဆုိၾကတယ္ ဘာလုိ.လဲဆုိေတာ့ သူ.တုိ.က language တခုကို (programming language ဆုိပါစုိ.) သတ္မွတ္ဖုိ.သံုးတဲ့ language မိုလို. meta language လို.ဆုိၾကတယ္။ Grammar ေတြ parsing အေၾကာင္းကိုနားလည္ရင္ natural langauge processing မွာလဲ တနည္းတဖံုသံုးလုိ.ရမယ္။ Compiler ေရးမဲ့လူေတြကေတာ့ Grammar ေတြအေၾကာင္းကို ေၾကေၾကၿငက္ၿငက္ နားလည္ရမယ္။ Theory အရ အရမ္းရွုပ္မွာစုိးလို. shadow knowledge ေလာက္ပဲ ေၿပာေတာ့မယ္။ Grammar ေတြအေၾကာင္းေလ့လာမယ္ဆုိရင္ သူ.တုိခ်ည္းအေၾကာင္းေရးထားတဲ့ စာအုပ္ေတြသက္သက္ရိွတယ္။
Context Free Grammar
Context free grammar ၿဖစ္ဖုိ.ရာ ေအာက္က element ေတြပါရတယ္။
ALPHABET is a finite set of symbols that appear in the language (သူကေတာ့ programming langauge တခုမွာ သံုးလို.ရတဲ့ အကၡရာေတြ symbol ေတြေပါ့ ဥပမာ a-z +-*/ အစရိွတာေတြ ဒါေတြကို alphabet လို.ေခၚတယ္) NONTERMALS symbols that can be replaced by collections of symbols found in a production (see below) (သူကေတာ့ rule ထပ္ခြဲလို.ရတဲ့ေကာင္ေတြေပါ့ ဥပမာ statement ေပါ့ statement ဆုိရင္ for, do,while, if, declaration အစရိွတာမ်ိဳးထပ္ခြဲလုိ.ရတယ္ ဒါဆုိရင္ statement သည္ nonterminal ေပါ့။) TERMINAL symbols from the alphabet (သူကေတာ့ ထပ္ခြဲလို.မရေတာ့တာ lexical element ေတြ လို.ေၿပာရမယ္ ဥပမာ Identifier , Identifier ကိုထပ္ခြဲဖုိ.မၿဖစ္ႏုိင္ေတာ့ဘူး။ string literal သူ.ကိုလဲထပ္ခြဲလို.မၿဖစ္ႏိုင္ေတာ့ဘူး language ရဲ. syntax အရ အေသးဆံုး ယူနစ္လို.ဆုိရမယ္။)  PRODUCTIONs replacement rules for nonterminals (ဒီေကာင္ကေတာ့ အေရးအၾကီးဆံုးပဲ ဒါကေတာ့ NonTerminal ေတြ terminal ေတြပါတဲ့ grammar rule ကိုေၿပာတာ) START SYMBOL the initial symbol from which all sentences in the language can be derived (ဒါကေတာ့ ဘယ္ production rule ကေန စခြဲမလဲဆုိေတာ့ symbol , parser ကဒီကေန စရတယ္) Backus-Naur Form (BNF) ဆုိတာ CFG ေတြကိုေရးတဲ့ အခါသံုးတဲ့ပံုစံတခုပဲ။ တၿခားၾကိဳက္တာတခုခုသံုးလဲရတယ္။
ဥပမာ ေအာက္ကၿပထားတာက simple english sentence ေလးကို CFG ထုတ္ထားတာ BNF notation နဲ.ၿပထားတာေပါ့။ <sentence> ::= <subject> <predicate> <subject> ::= <article> <noun> <predicate> ::= <verb> <direct-object> <direct-object> ::= <article> <noun> <article> ::= THE | A <noun> ::= MAN | DOG <verb> ::= BITES | PETS သူ.မွာပါတဲ့ Alphabet သည္ english symbol capital letter ေတြလို.ေၿပာလို.ရတယ္ (ဒီဥပမာ မွာဆုိ letter အားလံုးေတာင္မပါဘူး)
အေပၚက CFG မွာ NonTerminal သည္ (sentence, subject,predicate,direct-object,article,non,verb) ဘာလို.လဲဆုိေတာ့ အဲ့ေကာင္ေတြက production rule ရဲ. ဘယ္ဘက္မွာရိွတယ္သူ.တုိ.ကိုထပ္ခြဲလို.ရတယ္။ ဥပမာ sentence ဆုိရင္ subject predicate ဆုိၿပီး ထပ္ခြဲလို.၇တယ္ ဒါေၾကာင့္ non terminal လို.ဆုိရမယ္။  THE,A, MAN, DOG, BITES, PETS အဲ့ေကာင္ေတြကေတာ့ terminal ေပါ့ ထပ္ခြဲလို.မွမရေတာ့ပဲကုိး။  ေနာက္ ဒီလို
<sentence> ::= <subject> <predicate>
တေၾကာင္းကို production rule လို.ေခၚတယ္ အဓိပၸာယ္က sentence ကို Production rule ေတြမွာေတြ.ခဲ့ရင္ သူ.ကို subject predicate ဆုိၿပီးထပ္ခြဲလို.ရတယ္ ဆုိတဲ့ rule ကိုၿပတာ။အဂၤလိပ္သဒၵါအရ subject သည္အရင္လာရမယ္ ဒါေၾကာင့္ <subject> သူ.ေနာက္ကမွ <predicate> အဲ့လိုၿဖစ္ေနတာ။
CFG ရဲ.ထိပ္ဆံုး production rule ကို start symbol လုိ.ထားၾကတယ္။ ဒီေတာ့ sentence သည္ start symbol ေပါ့။ ဒါဆုိရင္အေပၚက CFG Grammar အရ ထုတ္ႏုိင္တဲ့ statement ေတြသည္ဒီလိုၿဖစ္လိမ့္မယ္။
A DOG BITES THE MAN  A MAN BITES THE DOG A MAN PETS A DOG
အဲ့လို statement ေတြထုတ္ႏုိင္လိမ့္မယ္။ အဲ့လို statement ေတြသည္ ခုနက CFG အရဆုိရင္ syntax အရ မွန္တယ္လို.ဆုိရမယ္။ ဒါဆုိရင္ ဘယ္လိုလုပ္ၿပီး Compiler က ခုနက statement ေတြကုိ syntax အရ မွန္တယ္လို.သိလဲေပါ့။ ဘယ္လိုသိလဲဆုိရင္ parse လုပ္ၿပီးသိတယ္လို.ဆုိရမယ္။ ဒါဆုိဘယ္လို parse လုပ္သလဲေပါ့။ အေပၚက statement ေတြကို production rule ေတြသံုးၿပီး တခုခ်င္းအစားထုိးမယ္ ဒီလိုနည္းနဲ.သိတယ္လို.ဆုိရမယ္။ ဒါကို derivation လို.ေခၚတယ္။ ဥပမာ ဒီ statement ေပါ့ A DOG BITES THE MAN  ဒါဆုိရင္ CFG က ဒီ statement ကုိဘယ္လိုမွန္သလဲဆုိတာသိလဲဆိုရင္ derivation ခြဲၾကည့္တယ္။ derivation ခြဲတယ္ဆုိတာ production rule ေတြကိုသံုးၿပီး တခုခ်င္းအစားထုိးသြားတာကိုေၿပာတာပါ။ ဘယ္ production rule ကေနစမလဲဆုိေတာ့ start symbol ကေန စရမယ္။ အဲ့ေတာ့ ပထမဆံုး derivation သည္  <sentence> ေပါ့။ sentence ကုိထပ္ခြဲရင္ ဒီလိုရမယ္။ <sentence>:= <subject> <predicate>
အဲ့မွာ production rule ရဲ. ညာဘက္ <subject><predicate> ၂ခုရိွတယ္ ဘက္ဘက္က <subject> ကုိထပ္ခြဲမယ္။ ဘယ္ကစခြဲတဲ့အတြက္ left most derivation လို.ဆုိတယ္။ subject ကို ထပ္ခြဲရင္ ဒီလိုရမယ္ <sentence>:=<subject><predicate> <sentence>:= <article> <noun><predicate> (ဒီအဆင့္မွာ subject ကို <article> <noun> အေနနဲ.ခြဲလိုက္တယ္။) ေနာက္ non-terminal ၿဖစ္တဲ့ article ကုိထပ္ခြဲမယ္၊ <article> rule ကိုဒီလိုေရးထားတယ္ <article> ::= THE | A ဆုိခ်င္တာက article သည္ THE သုိ.မဟုတ္ A ၿဖစ္ႏုိင္တယ္လို.ေၿပာတာ. vertical bar (|)သည္ or လို.အဓိပၸာယ္ရတယ္။ ဒါဆုိ derivation ကဒီလိုၿဖစ္သြားမယ္။ ဒီေနရာမွာ A DOG BITES THE MAN ကုိခြဲတာၿဖစ္တဲ့အတြက္ ထိပ္ဆံုး က A နဲ.သြားတူတယ္ ဒါေၾကာင့္ article ကို A နဲ.အစားထုိးလိုက္တယ္။ <sentence>:=<subject><predicate> <sentence>:= <article> <noun><predicate>  <sentence>:= A <noun><predicate>
ေနာက္ noun ကို အစားထိုးမယ္ ။ noun သည္ MAN or DOG ၿဖစ္ႏုိင္တယ္ input statement မွာ ေနာက္တလံုးက DOG ဆုိေတာ့ Dog နဲ.အစားထုိးမယ္။ <sentence>:=<subject><predicate>  <sentence>:= <article> <noun><predicate>  <sentence>:= A DOG <predicate> (noun ကုိ DOG နဲ. replace လုပ္တယ္)
ေနာက္တဆင့္ predicate ကုိခြဲမယ္။  <sentence>:=<subject><predicate>  <sentence>:= <article> <noun><predicate> <sentence>:= A DOG <verb> <direct-object> (predicate ကို <verb> <direct-object> နဲ.ခြဲတယ္) ေနာက္တဆင့္ဆုိ <sentence>:=<subject><predicate>  <sentence>:= <article> <noun><predicate>  <sentence>:= A DOG <verb> <direct-object>  <sentence>:= A DOG BITES <direct-object> (verb ကုိ BITES နဲ. replace လုပ္လိုက္တယ္)
ေနာက္တဆင့္။ <sentence>:=<subject><predicate>  <sentence>:= <article> <noun><predicate>  <sentence>:= A DOG <verb> <direct-object>  <sentence>:= A DOG BITES <article> <noun>(direct object ကို article noun ထပ္ခြဲတယ္)
ေနာက္တဆင့္ဆုိ
<sentence>:=<subject><predicate>  <sentence>:= <article> <noun><predicate>  <sentence>:= A DOG <verb> <direct-object>  <sentence>:= A DOG BITES THE <noun> (article ကုိ THE နဲ. အစားထုိးတယ္) ေနာက္ဆံုးအဆင့္  <sentence>:=<subject><predicate>  <sentence>:= <article> <noun><predicate>  <sentence>:= A DOG <verb> <direct-object>  <sentence>:= A DOG BITES THE MAN( noun ကုိ MAN နဲ.အစားထုိးတယ္)
ေနာက္ဆံုးအဆင့္ production rule ရဲ. ညာဘက္မွာ terminal ေတြပဲက်န္ေတာ့တယ္ဆုိရင္ ဒါသည္ syntax အရမွန္တယ္ ခြဲလုိ.ရတယ္။ Grammar အရမွန္တယ္လို.ဆုိရမယ္။ မဟုတ္ပဲ production rule ေတြေတာ့က်န္ေသးတယ္ ထပ္ခြဲလို.မရေတာ့ဘူးဆုိရင္ ဒါသည္ syntax အရမွားတယ္လို.ဆုိရမယ္။ ဥပမာ CAT BITS DOG ဒီ statement ကုိခြဲဖုိ. CAT ဆုိတာမရိွတဲ့အတြက္ <sentence>=><subject><predicate>=> <article><noun> <priedicate> ဆုိတဲ့ rule က်ရင္ article မွာ CAT မရိွတဲ့အတြက္ error တက္ၿပီလို.ဆိုရမယ္။ အေပၚက ဥပမာၿပသြားတဲ့ production rule ကို တဆင့္ခ်င္းခြဲခ်တာကို parsing လုပ္တယ္လုိ.ေၿပာ၇မယ္။ derivation လုိ.လဲသံုးတယ္။ သြားခဲ့တဲ့အဆင့္ေတြကို tree ဆြဲခ်ရင္ဒီလိုရမယ္။
အေပၚက ဥပမာ ၿပသြားတာကို left most derivation လို.ေခၚတယ္ ညာဘက္အစြန္ဆံုး non terminal ကေနခြဲတဲ့နည္းလဲရိွတယ္ ဒါကို right most derivation လိုေခၚတယ္. left most derivation မွာ tree building သည္ ထိပ္ဆံုးကေနေဆာက္တယ္ ဒါေၾကာင့္ top down parsing လို.ေခၚတယ္ ေနာက္ rightmost မွာေတာ့ ေအာက္ဆံုးကေနစတယ္ ဒါေၾကာင့္ bottom up လို.ေခၚတယ္။ Top down parser ေတြက လက္ခံတဲ့ grammar ေတြနဲ. bottom up ကလက္ခံတဲ့ grammar အမ်ိဳးအစားလဲမတူၾကဘူး။ ဒါကေတာ့ compiler ေရးတဲ့သူေတြေလာက္သာသိရမွာမုိ.ခ်န္ထားခဲ့မယ္ ေနာက္တပုိင္းမွာ example CFG ကိုဘယ္လို parser ေရးမလဲကိုေၿပာၾကတာေပါ့။

￼
